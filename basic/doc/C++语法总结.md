# 类和对象

## 基础点
　
* 类定义话括号后面的分号不能少
* 未声明权限的成员默认private
* 类内声明类内定义属于内联模式(inline只能在类内声明时用,不能再类外定义时用)
* 类外定义成员函数格式为**返回值 类名::成员函数名(参数表){}**
* 常成员函数和常返回 **const 返回值 函数名() const;** 第一个const表示返回的引用是不能被修改的

## 构造函数和析构函数
* 析构函数只能有一个
* 构造函数无返回类型
* 构造函数约束必须带参数，将默认构造函数私有化或者不提供默认构造函数
* 找不到任何构造函数才会生成默认构造函数
* 对const类型的成员变量初始化时必须为构造函数添加一个初始化列表
* new和new[]会调用构造函数,malloc和calloc不会

### 拷贝构造函数
* 拷贝构造函数必须用引用参数
* 拷贝构造函数可以有多个参数，但是除了第一个都必须有默认值
* 如果没定义拷贝构造函数编译器会给你一个
* 如果一个类含有指向动态存储空间的指针时就必须定义拷贝构造函数(深拷贝)
* 禁止对象拷贝,使用对象作为函数参数或者返回值时,将会对参数对象进行拷贝(调用该对象的拷贝构造函数),这样会浪费空间与时间,如果需要禁用传值方式那么将拷贝构造函数私有化
* 单同类对象引用参数会被默认为拷贝构造函数

### 转型构造函数
* 参数数据类型转为类对象类型
* 函数重栽中类对象参数可由普通参数代替,前提是存在该普通参数的转型构造函数,这个功能可以有explicit关键字来关闭,explicit加在转型构造函数之前
  
### 类数据成员和类成员函数
* static成员属于类本身而非类对象
* static函数中不能存在非static数据
* const成员函数由const对象来调用
* const成员函数可以支持重载(存在同名同参数签名的函数)
* this是一个常量指针
* this不能访问类的静态成员
  
# 继承

## 基础点
* 继承时不写继承方式默认为private继承
* 子类会为父类的私有成员分配空间，虽然访问不到，可以通过父类的可访问方法访问
* 子类能在private区中使用```using Base:method();```使父类公有方法变为私有，使得子类能够除去父类中继承来的多余的特性
* 同名成员隐藏，只要名字相同就能隐藏，而非参数签名相同（调用最近原则）
* 一般来说，数据为private，函数方法为public或protected
* public继承方式为公变公、保变保；protected为公变保
* 子类不继承父类的构造函数和析构函数
* 子类构造函数基本格式```Derived(int m, int n, int k):Base( m, n);```
* 构造函数调用顺序：父、客（成员）、子
* 若父类无缺省构造函数，编译器会给一个
* 若父类无缺省构造函数但是有显式构造函数，则子类构造函数要显示的指出调用父类的哪一个构造函数
* 数据成员的初始化顺序与被申明顺序有关，与构造函数的成员初始化列表顺序无关

## 多继承
* 多继承格式一般为```class Derived : public B1, private B2, protected B3{};```，该顺序决定父类构造函数调用顺序
* 命名冲突，使用显示调用区别开（隐式调用下，同层报错，不同层遮蔽）
    * 父类1与父类2，如果不显示调用则编译报错```derived.Base1::func1();```
    * 父类与子类，如果不显示调用则遮蔽父类方法（调用最近原则）```derived.Base1::func1();```

### 虚基类
* 一个类不能直接继承父类多次，但是添加中间类就可以实现对一个类的重复继承（比如：菱形结构）
* 中间层使用虚继承以解决二义性问题
  ```
    class B1 ：vritual public B{};
    class B2 ：vritual public B{};
    class D : public B1, public B2{};
    //使得d.B1::x d.B2::x d.x指到一个变量
  ```
* 深刻理解以下例子以题型对虚继承中遮蔽原则的理解:
  ```
    class B{
        public:
            B():x(5){}
        private:
            int x;
    };

    class B1 : virtual public B{
        public:
            void t() {
                x = 15;
                cout<<x<<endl;
            }
            int x;
    };

     class B2 : virtual public B{
        public:
            void t() {
                cout<<x<<endl;
            }
    };

    class D : public B1, public B2{
        public:
            void t(){cout<<x<<'\t'<<B1::x<<'\t'<<B2::x<<endl;}
    };
    D d; d.x = 10; //out：10 10 5
  ```

* 虚基类的构造函数由最派生类来调用，中间类对虚基类构造函数的调用会直接跳过
---161


