# 类和对象

## 基础点
　
* 类定义话括号后面的分号不能少
* 未声明权限的成员默认private
* 类内声明类内定义属于内联模式(inline只能在类内声明时用,不能再类外定义时用)
* 类外定义成员函数格式为**返回值 类名::成员函数名(参数表){}**
* 常成员函数和常返回 **const 返回值 函数名() const;** 第一个const表示返回的引用是不能被修改的

## 构造函数和析构函数
* 析构函数只能有一个
* 构造函数无返回类型
* 构造函数约束必须带参数，将默认构造函数私有化或者不提供默认构造函数
* 找不到任何构造函数才会生成默认构造函数
* 对const类型的成员变量初始化时必须为构造函数添加一个初始化列表
* new和new[]会调用构造函数,malloc和calloc不会

### 拷贝构造函数
* 拷贝构造函数必须用引用参数
* 拷贝构造函数可以有多个参数，但是除了第一个都必须有默认值
* 如果没定义拷贝构造函数编译器会给你一个
* 如果一个类含有指向动态存储空间的指针时就必须定义拷贝构造函数(深拷贝)
* 禁止对象拷贝,使用对象作为函数参数或者返回值时,将会对参数对象进行拷贝(调用该对象的拷贝构造函数),这样会浪费空间与时间,如果需要禁用传值方式那么将拷贝构造函数私有化
* 单同类对象引用参数会被默认为拷贝构造函数

### 转型构造函数
* 参数数据类型转为类对象类型
* 函数重栽中类对象参数可由普通参数代替,前提是存在该普通参数的转型构造函数,这个功能可以有explicit关键字来关闭,explicit加在转型构造函数之前
  
### 类数据成员和类成员函数
* static成员属于类本身而非类对象
* static函数中不能存在非static数据
* const成员函数由const对象来调用
* const成员函数可以支持重载(存在同名同参数签名的函数)
* this是一个常量指针
* this不能访问类的静态成员
  
# 继承

## 基础点
* 继承时不写继承方式默认为private继承
* 子类会为父类的私有成员分配空间，虽然访问不到，可以通过父类的可访问方法访问
* 子类能在private区中使用```using Base:method();```使父类公有方法变为私有，使得子类能够除去父类中继承来的多余的特性
* 同名成员隐藏，只要名字相同就能隐藏，而非参数签名相同（调用最近原则）
* 一般来说，数据为private，函数方法为public或protected
* public继承方式为公变公、保变保；protected为公变保
* 子类不继承父类的构造函数和析构函数
* 子类构造函数基本格式```Derived(int m, int n, int k):Base( m, n);```
* 构造函数调用顺序：父、客（成员）、子
* 若父类无缺省构造函数，编译器会给一个
* 若父类无缺省构造函数但是有显式构造函数，则子类构造函数要显示的指出调用父类的哪一个构造函数
* 数据成员的初始化顺序与被申明顺序有关，与构造函数的成员初始化列表顺序无关
* 子类继承来的方法可以通过B和D作用域都访问得到``` d.B::fun(); d.D::fun();```都合法,选择域只是指定了对象的内存模型，而子类的内存模型里有父类的fun()

## 多继承
* 多继承格式一般为```class Derived : public B1, private B2, protected B3{};```，该顺序决定父类构造函数调用顺序
* 命名冲突，使用显示调用区别开（隐式调用下，同层报错，不同层遮蔽）
    * 父类1与父类2，如果不显示调用则编译报错```derived.Base1::func1();```
    * 父类与子类，如果不显示调用则遮蔽父类方法（调用最近原则）```derived.Base1::func1();```

### 虚基类
* 一个类不能直接继承父类多次，但是添加中间类就可以实现对一个类的重复继承（比如：菱形结构）
* 中间层使用虚继承以解决二义性问题
  ```
    class B1 ：vritual public B{};
    class B2 ：vritual public B{};
    class D : public B1, public B2{};
    //使得d.B1::x d.B2::x d.x指到一个变量
  ```
* 深刻理解以下例子以题型对虚继承中遮蔽原则的理解:
  ```
    class B{
        public:
            B():x(5){}
        private:
            int x;
    };

    class B1 : virtual public B{
        public:
            void t() {
                x = 15;
                cout<<x<<endl;
            }
            int x;
    };

     class B2 : virtual public B{
        public:
            void t() {
                cout<<x<<endl;
            }
    };

    class D : public B1, public B2{
        public:
            void t(){cout<<x<<'\t'<<B1::x<<'\t'<<B2::x<<endl;}
    };
    D d; d.x = 10; //out：10 10 5
  ```

* 虚基类的构造函数由最派生类来调用，中间类对虚基类构造函数的调用会直接跳过
* **只有在公有继承下**，子类是父类的子类型，子类拥有父类的特性，可以作为父类来被使用，减轻开发负担而不必重载；可以派生赋值给基类（对象，引用，指针），但不可逆


# 多态

## 基础点
* **运行时绑定**指的是编译的时候，跳转的函数入口地址不写死，而写的是函数名，通过调用对象的类型来动态计算函数的入口地址
* 虚函数格式```virtual ret_type fun(...){}```
* 多态必要条件
    * 必须通过基类指针或者引用才能调用
    * 有继承结构，且继承结构中的多个类含有同名的虚函数
* 虚函数在所有子类中仍然是虚函数，即使没有显式的声明，规范是最好在子类中也加上便于观察
* virtual关键字仅在声明的时候使用，定义时不用加
* 深刻理解以下例子以加深对多态的理解：
  ```  
  Class A {
    public:
      virtual void act1(){cout<<"A::act1"};
      A(){act1();}
      void act2() {act1();}
  };
  Class B : public A{
    public:
      B(){}
      virtual void act1(){cout<<"B::act1"};
  };

  A *a = new B();
  a->act2(); //out: B:act1
  this->act2(); //out: B:act1
  a->A::act2(); //out: B:act1 
  // 在act2中调用act1，满足多态必要条件，动态运行B::act1

  B b; //out:A::act1
  ```
* 构造函数中调用虚函数时，使用的是本类或者本类以上的该虚函数，因为此时派生类还未初始化完毕，无法使用多态
* 一般情况下，函数定义中加上了作用域选择的话使用的是静态联编
* 虚成员函数表vtable中会指明B::fun()和D::fun()的具体入口地址，然后动态的来决定使用哪一个；每个类都维护一个虚成员函数表
* 构造函数不能为虚函数（还没构造出来无法在动态运行时分辨类型），析构函数可以为虚函数
* 虚析构函数能够防止内存泄漏
* 静态成员函数不能是虚成员函数
* 覆盖（override） 1.虚函数 2.函数签名相同 
* 遮蔽（hiding） 1.函数名相同（无关虚实）

## 抽象基类
* 含有纯虚函数```virtual ret_type fun(...)=0;```的类为抽象基类，必须由子类来覆盖纯虚函数 
* 抽象基类无法被实例化，也不能作为参数类型
* 但是可以申明抽象基类的指针和引用以满足多态特性

## 类类型转化
* 派生类赋值给基类指针或引用是合法的，但是反过来可能会出现错误
* 上述转化用static_cast能够实现编译通过，但运行可能报错
* dynamic_cast<T*>仅对多态使用，前提是转换源要有虚函数，不关心转换目标是否有虚函数,且目标必须是指针或者引用
* dynamic_cast<T*>向上转可以，向下转一般不会成功，下转上再转下不知道可以，待编码检查~~
* typeid可用来做类型检查```typeid(x)==typeid(y```
  ```
  //多态环境下：
  Base * b = new Derived();
  typeid(b)==typeid(Derived*) //false
  typeid(b)==typeid(Base *) //true
  typeid(*b)==typeid(Base) //false
  typeid(*b)==typeid(Derived) //true

  Base & b = new Derived();
  typeid(b)==typeid(Derived) //true
  ppt128待仔细看
  ```
 

  


