# 类和对象

## 基础点
　
* 类定义话括号后面的分号不能少
* 未声明权限的成员默认private
* 类内声明类内定义属于内联模式(inline只能在类内声明时用,不能再类外定义时用)
* 类外定义成员函数格式为**返回值 类名::成员函数名(参数表){}**
* 常成员函数和常返回 **const 返回值 函数名() const;** 第一个const表示返回的引用是不能被修改的

## 构造函数和析构函数
* 析构函数只能有一个
* 构造函数无返回类型
* 构造函数约束必须带参数，将默认构造函数私有化或者不提供默认构造函数
* 找不到任何构造函数才会生成默认构造函数
* 对const类型的成员变量初始化时必须为构造函数添加一个初始化列表
* new和new[]会调用构造函数,malloc和calloc不会

### 拷贝构造函数
* 拷贝构造函数必须用引用参数
* 拷贝构造函数可以有多个参数，但是除了第一个都必须有默认值
* 如果没定义拷贝构造函数编译器会给你一个
* 如果一个类含有指向动态存储空间的指针时就必须定义拷贝构造函数(深拷贝)
* 禁止对象拷贝,使用对象作为函数参数或者返回值时,将会对参数对象进行拷贝(调用该对象的拷贝构造函数),这样会浪费空间与时间,如果需要禁用传值方式那么将拷贝构造函数私有化
* 单同类对象引用参数会被默认为拷贝构造函数

### 转型构造函数
* 参数数据类型转为类对象类型
* 函数重栽中类对象参数可由普通参数代替,前提是存在该普通参数的转型构造函数,这个功能可以有explicit关键字来关闭,explicit加在转型构造函数之前
  
### 类数据成员和类成员函数
* static成员属于类本身而非类对象
* static函数中不能存在非static数据
* const成员函数由const对象来调用
* const成员函数可以支持重载(存在同名同参数签名的函数)
* this是一个常量指针
* this不能访问类的静态成员
  
# 继承

## 基础点
* 继承时不写继承方式默认为private继承
* 子类会为父类的私有成员分配空间，虽然访问不到，可以通过父类的可访问方法访问
* 子类能在private区中使用```using Base:method();```使父类公有方法变为私有，使得子类能够除去父类中继承来的多余的特性
* 同名成员隐藏，只要名字相同就能隐藏，而非参数签名相同（调用最近原则）
* 一般来说，数据为private，函数方法为public或protected
* public继承方式为公变公、保变保；protected为公变保
* 子类不继承父类的构造函数和析构函数
* 子类构造函数基本格式```Derived(int m, int n, int k):Base( m, n);```
* 构造函数调用顺序：父、客（成员）、子
* 若父类无缺省构造函数，编译器会给一个
* 若父类无缺省构造函数但是有显式构造函数，则子类构造函数要显示的指出调用父类的哪一个构造函数
* 数据成员的初始化顺序与被申明顺序有关，与构造函数的成员初始化列表顺序无关
* 子类继承来的方法可以通过B和D作用域都访问得到``` d.B::fun(); d.D::fun();```都合法,选择域只是指定了对象的内存模型，而子类的内存模型里有父类的fun()

## 多继承
* 多继承格式一般为```class Derived : public B1, private B2, protected B3{};```，该顺序决定父类构造函数调用顺序
* 命名冲突，使用显示调用区别开（隐式调用下，同层报错，不同层遮蔽）
    * 父类1与父类2，如果不显示调用则编译报错```derived.Base1::func1();```
    * 父类与子类，如果不显示调用则遮蔽父类方法（调用最近原则）```derived.Base1::func1();```

### 虚基类
* 一个类不能直接继承父类多次，但是添加中间类就可以实现对一个类的重复继承（比如：菱形结构）
* 中间层使用虚继承以解决二义性问题
  ```
    class B1 ：vritual public B{};
    class B2 ：vritual public B{};
    class D : public B1, public B2{};
    //使得d.B1::x d.B2::x d.x指到一个变量
  ```
* 深刻理解以下例子以题型对虚继承中遮蔽原则的理解:
  ```
    class B{
        public:
            B():x(5){}
        private:
            int x;
    };

    class B1 : virtual public B{
        public:
            void t() {
                x = 15;
                cout<<x<<endl;
            }
            int x;
    };

     class B2 : virtual public B{
        public:
            void t() {
                cout<<x<<endl;
            }
    };

    class D : public B1, public B2{
        public:
            void t(){cout<<x<<'\t'<<B1::x<<'\t'<<B2::x<<endl;}
    };
    D d; d.x = 10; //out：10 10 5
  ```

* 虚基类的构造函数由最派生类来调用，中间类对虚基类构造函数的调用会直接跳过
* **只有在公有继承下**，子类是父类的子类型，子类拥有父类的特性，可以作为父类来被使用，减轻开发负担而不必重载；可以派生赋值给基类（对象，引用，指针），但不可逆


# 多态

## 基础点
* **运行时绑定**指的是编译的时候，跳转的函数入口地址不写死，而写的是函数名，通过调用对象的类型来动态计算函数的入口地址
* 虚函数格式```virtual ret_type fun(...){}```
* 多态必要条件
    * 必须通过基类指针或者引用才能调用
    * 有继承结构，且继承结构中的多个类含有同名的虚函数
* 虚函数在所有子类中仍然是虚函数，即使没有显式的声明，规范是最好在子类中也加上便于观察
* virtual关键字仅在声明的时候使用，定义时不用加
* 深刻理解以下例子以加深对多态的理解：
  ```  
  Class A {
    public:
      virtual void act1(){cout<<"A::act1"};
      A(){act1();}
      void act2() {act1();}
  };
  Class B : public A{
    public:
      B(){}
      virtual void act1(){cout<<"B::act1"};
  };

  A *a = new B();
  a->act2(); //out: B:act1
  this->act2(); //out: B:act1
  a->A::act2(); //out: B:act1 
  // 在act2中调用act1，满足多态必要条件，动态运行B::act1

  B b; //out:A::act1
  ```
* 构造函数中调用虚函数时，使用的是本类或者本类以上的该虚函数，因为此时派生类还未初始化完毕，无法使用多态
* 一般情况下，函数定义中加上了作用域选择的话使用的是静态联编
* 虚成员函数表vtable中会指明B::fun()和D::fun()的具体入口地址，然后动态的来决定使用哪一个；每个类都维护一个虚成员函数表
* 构造函数不能为虚函数（还没构造出来无法在动态运行时分辨类型），析构函数可以为虚函数
* 虚析构函数能够防止内存泄漏
* 静态成员函数不能是虚成员函数
* 覆盖（override） 1.虚函数 2.函数签名相同 
* 遮蔽（hiding） 1.函数名相同（无关虚实）

## 抽象基类
* 含有纯虚函数```virtual ret_type fun(...)=0;```的类为抽象基类，必须由子类来覆盖纯虚函数 
* 抽象基类无法被实例化，也不能作为参数类型
* 但是可以申明抽象基类的指针和引用以满足多态特性

## 类类型转化
* 派生类赋值给基类指针或引用是合法的，但是反过来可能会出现错误
* 上述转化用static_cast能够实现编译通过，但运行可能报错
* dynamic_cast<T*>仅对多态使用，前提是转换源要有虚函数，不关心转换目标是否有虚函数,且目标必须是指针或者引用
* dynamic_cast<T*>向上转可以，向下转一般不会成功，下转上再转下不知道可以，待编码检查~~
* typeid可用来做类型检查```typeid(x)==typeid(y```
  ```
  //多态环境下：
  Base * b = new Derived();
  typeid(b)==typeid(Derived*) //false
  typeid(b)==typeid(Base *) //true
  typeid(*b)==typeid(Base) //false
  typeid(*b)==typeid(Derived) //true

  Base & b = new Derived();
  typeid(b)==typeid(Derived) //true
  ppt128待仔细看
  ```
 
# 操作符重载

## 基本点
* 语法：```ret_type operator运算符(...)```
* 不能被重载的运算符：?:(三目运算符比较复杂) .和*（保证访问安全）::(左边操作数不是表达式而是类型名)
*  赋值运算符=被重载以后不会被派生类继承，其他的运算法重载都会被派生类继承
*  重载不改变操作符的优先级和语法
*  顶层函数操作符重载时，参数表必须包含一个类对象（类中重载就肯定不会混淆，因为调用方肯定是类对象）
* [] = () ->必须类中重载，因为他们左值都必须是类对象
* 类内重载调用方必须为类对象,合法：a+23（23调用转型构造),不合法：23+a;而顶层重载就无这个顾虑（前提是有转型构造函数）
* 编译器解释运算符的顺序：1.找类成员运算符 2.找友元或者顶层运算符 3.找转换构造或者转换重载以满足运算符语法 4.编译器报错

## 友元函数
* 顶层重载中的私有成员访问权限问题：1.私有成员改公有 2.暴露公有成员访问函数 3.将重载设置为友元
* 友元不是类的成员，建议只在操作符重载时使用
* 友元函数申明格式```friend ret_t opertor操作符(...);```;定义格式``` ret_t opertor操作符(...){...};```定义时不用加类选择符
* 友元函数可以是其他类的成员函数```friend ret_t A::fun(...);```
* 友元类```friend class B;```
* 友元关系单向、不传递
  
## 输入输出操作符重载
* \>>和<<因为参数（左值）中含有系统类，故而只能使用顶层重载的方式```instream& operator>>(instream& in, class& A);```
* 多值一行时左结合

## 赋值运算符重载
* 赋值运算符重载不能是static的，且不会被子类继承
* 拷贝构造函数是根据已有对象**创建**一个新类对象,赋值运算符重载是根据一个已有对象赋值给另一个已存在对象
* 如果类中没有拷贝构造和赋值重载，编译器会给一个默认
* 需要深拷贝时，需要重写拷贝构造函数和赋值运算符重载
* 多值一行时右结合
* 注意判断自我赋值

## 特殊操作符重载
* []、()操作符只能重载为类成员函数，不能重载为友元函数，只能带一个形参作为下标
* []重载可以添加下标越界检测
* （）可以用来只通过对象名就完成一个类似函数的功能```class b; b(...);```
* 区分i++和++i重载```operator++()//前置 operator++(int)//后置```
* 转型操作符重载（自己转其他）与转型构造函数（其他转自己），转型重载格式：```operator other_type(){};```
* 转型重载不包含形参和返回类型，不能定义为友元

## 关联式数组Dict

## 内存管理操作符


